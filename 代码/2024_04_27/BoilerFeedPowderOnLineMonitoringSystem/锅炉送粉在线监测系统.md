# 锅炉送粉在线监测系统

> 程序功能:

-  一次风燃烧器出口风速在线监测；
-  一次风管煤粉浓度在线监测；
-  一次风粉模拟切圆；
-  一次风浓度和速度半小时实时趋势图及两小时历史趋势图；
-  一次风管温度在线监测;
-  1000次报警数据纪录;
-  入炉煤量纪录,

> 程序环境

VS2022, QT5.14.2版本, C++11

# 程序思路

这个程序是基于QT进行开发的,基本思路是使用两个线程.

- 子线程： 作为数据处理线程,将外界传输的数据通过切割分离成一个个数据类,然后使用已经写好的处理函数进行处理,将结果通过QT的信号与槽机制传递给主线程
- 主线程： 将接受的已经被处理的数据通过派发给主线程的各个界面内

程序退出后,主线程调用子线程的函数,让子线程退出,进行资源析构,防止内存泄漏.当子线程退出后,主线程进行析构.

# 程序模块

主要分为四个模块.

- 系统设置
- 状态查看
- 数据处理
- 帮助

# 程序启动

程序启动后, 优先启动"欢迎界面",由于所有的功能都在主界面上,此时main函数需要做一定的处理.

![image-20240613125648067](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613125648067.png)

```cpp
#include "BoilerFeedPowderOnLineMonitoringSystem.h"
#include <QtWidgets/QApplication>

int main(int argc, char* argv[])
{
	QApplication a(argc, argv);
	BoilerFeedPowderOnLineMonitoringSystem w; // 实例化所有功能的类
	w.hide();   // 主页面暂时先隐藏
	return a.exec();
}
```

暂时简绍一下**BoilerFeedPowderOnLineMonitoringSystem**类,这是所有功能的集合,其中WelcomeScreen是欢迎界面,它存在ui文件.

```cpp
class BoilerFeedPowderOnLineMonitoringSystem : public QMainWindow
{
	Q_OBJECT

public:
	BoilerFeedPowderOnLineMonitoringSystem(QWidget* parent = nullptr);
	~BoilerFeedPowderOnLineMonitoringSystem();

	void init();
    void initWelcomeScreen();  // 
private:
	Ui::BoilerFeedPowderOnLineMonitoringSystemClass* ui;

	WelcomeScreen* _welcome_screen;   //   欢迎界面

};
```

为了优先显示欢迎界面,此时需要在构造函数中进行处理

```cpp
BoilerFeedPowderOnLineMonitoringSystem::BoilerFeedPowderOnLineMonitoringSystem(QWidget* parent)
	: QMainWindow(parent)
	, ui(new Ui::BoilerFeedPowderOnLineMonitoringSystemClass())
	, _welcome_screen(nullptr)
{
	ui->setupUi(this);
    init();
}
// 欢迎界面
void BoilerFeedPowderOnLineMonitoringSystem::initWelcomeScreen()
{
	if (_welcome_screen == nullptr)
		_welcome_screen = new WelcomeScreen(nullptr);

	connect(_welcome_screen, &WelcomeScreen::welcomeScreenCloseSignals, [=]() {
		// 一般而言,我们欢迎界面只出现一次,
		// 一旦我们选择叉掉这个界面,可以认为是整个程序都要退出
		_welcome_screen = nullptr;
		this->close();
		});
	//设置子窗体属性：关闭即销毁
	_welcome_screen->setAttribute(Qt::WA_DeleteOnClose);
	_welcome_screen->show();

	// 欢迎界面到 主界面
	connect(_welcome_screen, &WelcomeScreen::fromWelToMianScreenSignals, [=]() {
		this->show();
		_welcome_screen->hide();
		});
}
```

对于QT而言, 欢迎窗口由于是最先出现的,后面就不会出现了.此时需要设置窗口一经关闭就立马释放资源,避免内存泄漏.

```cpp
	_welcome_screen->setAttribute(Qt::WA_DeleteOnClose);
```

# 子线程

进行数据处理,并将数据结果发送给主线程.具体框架.

```cpp
/*
* 这是一个线程类,这个线程主要就是将我们的数据进行计算
* 把计算的结果通过槽函数返回到主线程中
*/
#include <QThread>
#include <iostream>
#include "Task.h"
#include <iostream>
#include <fstream>
#include "AlertData.h"
#include <unordered_map>
#include "ChannelData.h"
#include <unordered_set>

class MyThread : public QThread
{
	Q_OBJECT

public:
	MyThread(QObject* parent = nullptr);
	~MyThread();
	void init();
	void run() override;
	void quitThread(); // 退出该线程
signals:
	void saveCoefficientSignals(const std::vector<std::string>);         // 得到系数
	void produceAllDataSignals(std::vector<struct Result>);              // 传递所有的数据
	void produceAlarmDataSignals(std::vector<struct AlertData>);         // 传递报警数据
	void produceChannelDataSignals(std::vector<struct ChannelData>);     // 传递报警数据
private:
	void cleanseData(const std::vector<struct Result>&); // 把我们的处理后的结果进行检测是否是报警数据
	void parse(Task*, const std::string&);
	void slicedString(std::vector<std::string>*, const std::string&);// 切分字符串
private:
	volatile bool _quit_flag;
	std::vector<double> _area;                          // 保存面积
	std::vector<double> _coefficient_of_backrest_tube;  // 保存靠背管系数
	std::unordered_map<std::string, std::unordered_map<std::string, std::pair<std::string, double>>> _hash_alarm;  // 惊醒报警数据的清洗工作
	std::unordered_map<std::string, std::unordered_map<std::string, std::pair<std::string, double>>> _hash_channe; // 惊醒通道数的清洗工作
};
```

## 数据处理模块

这个模块来源于**一次风风粉在线监测系统数学模型**文档,主要计算下面的结果.

- 风速
- 空气比热
- 煤粉比热
- 煤粉浓度
- 煤粉质量流量
- 风量

我把这些集成到一个静态类中了,类名为**MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem**,这里函数的写法可能会有些错误,可以调试时进行修改

```cpp
#include <iostream>
#include <cmath>
class MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem
{
public:
	enum UNITOPTION
	{
		FORCEOFPRESSURE,	  // 帕斯卡
		COLUMNOFMERCURY,	  // 厘米汞柱
		TEMPERATUREINCELSIUS, // 摄氏度温标
		TEMPERATUREINKELVIN	  // 开尔文温度
	};

private:
	/*
	 * 计算空气比热和煤粉比热
	 * specific_heat_of_air:空气比热
	 * specific_heat_of_pulverized_coal:煤粉比热
	 * temperature:温度
	 */
	static void specificHeat(double* specific_heat_of_air,
		double* specific_heat_of_pulverized_coal,
		double temperature,
		bool unit_temperature = UNITOPTION::TEMPERATUREINCELSIUS);
public:
	/*
	 * 计算风速
	 * 测速管风洞标定系数:   calibration_coefficient_for_tachometer_wind_tunnel
	 * 温度:               temperature
	 * 测量的差压:          differential_pressure
	 */
	static void WindSpeed(double* wind_speed,
		double temperature,
		const double& differential_pressure,
		const double& calibration_coefficient_for_tachometer_wind_tunnel,
		bool unit_temperature = UNITOPTION::TEMPERATUREINCELSIUS,
		bool unit_option = UNITOPTION::FORCEOFPRESSURE);
	/*
	* 计算煤粉浓度
	* temperature: 各点的温度
	* pulverized_coal_concentration:煤粉浓度
	*/
	static void pulverizedCoalConcentration(double* pulverized_coal_concentration,
		double temperature_1,
		double temperature_2,
		double temperature_3);
	/*
	 * 计算煤粉质量流量
	 * wind_speed:一次风速
	 * cross_sectional_area_of_primary_duct:一次风管截面积
	 * the_density_of_air_under_standard_conditions:空气在标准状况下的密度
	 * primary_air_temperature:一次风温
	 * pulverized_coal_concentration:煤粉浓度
	 * pulverized_coal_mass_flow_rate:煤粉质量流量
	 */
	static void pulverizedCoalMassFlowRate(double* pulverized_coal_mass_flow_rate,
		double wind_speed,
		double cross_sectional_area_of_primary_duct,
		double primary_air_temperature,
		double pulverized_coal_concentration,
		double the_density_of_air_under_standard_conditions = 1.29,
		bool unit_temperature = UNITOPTION::TEMPERATUREINCELSIUS);
	/*
	 * 计算风量
	 * wind_speed:一次、二次、三次风速
	 * cross_sectional_area_of_primary_duct:一次、二次、三次风管截面积
	 */
	static void airVolume(double* air_volume,
		const double& wind_speed,
		const double& cross_sectional_area_of_primary_duct);
};
```

## 子线程流程

> 如何退出子线程:主线程退出时,调用子线程的函数,使得while循环结束.

```cpp
void MyThread::quitThread()
{
	_quit_flag = true;
}
void MyThread::run()
{
	while (!_quit_flag)
	{
	}
	// 子进程退出
	QThread::quit();
}
```

> 通过数据处理我们会发现,我们这里需要一些参数,这些参数都被放在一个叫做**configure.old - 副本.txt**文件中了,由于主线程需要修改这些参数,因此我们需要通过信号与槽机制将这些参数由主线程传递给子线程.

```cpp
void MyThread::run()
{
	while (!_quit_flag)
	{
		// 确定我们的参数已经可以拿去了
		if (_area.empty() || _coefficient_of_backrest_tube.empty())
		{
			std::cout << "area and coefficient_of_backrest_tube is empty" << std::endl;
			sleep(1);
			continue;
		}
	}
	// 子进程退出
	QThread::quit();
}
```

> 数据读取与清洗,这个版本的数据来源为**test.csv**,格式如下所示,一行数据就代表24个监测点.

![image-20240613102015118](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613102015118.png)

> 这个文件中的一些数据是随意的,有可能符合实际,仅仅作为测试.下面我们说一下具体的数据流程.

> 得到一行数据

```cpp
void MyThread::run()
{
	bool headerData = true;
	std::string path = "./test.csv"; // 数据读取的位置
	std::ifstream ifs;
	ifs.open(path.c_str(), std::ifstream::in);
	std::string line;  // 将每一行的数据存到line中
	std::getline(ifs, line); // 清除掉第一行

	while (!_quit_flag)
	{
		// 确定我们的参数已经可以拿去了
		if (_area.empty() || _coefficient_of_backrest_tube.empty())
		{
			std::cout << "area and coefficient_of_backrest_tube is empty" << std::endl;
			sleep(1);
			continue;
		}
		// 下面是模拟我们数据处理的结果,然后发送过去的
		int j = 0;
		int begin = time(NULL);

		while (!_quit_flag)
		{
			std::getline(ifs, line);
		}

	}

	ifs.close();
	// 子进程退出
	QThread::quit();
}
```

> 对数据进行清理,

```cpp
void MyThread::run()
{
	while (!_quit_flag)
	{
		while (!_quit_flag)
		{
			std::getline(ifs, line);
			Task task;
            parse(&task, line);
            task.run();                     // 这里一个task就是我们24个监测点所有的数据,run函数是数据处理
            cleanseData(task._primary_result);                  // 清洗报警数据
            emit produceAllDataSignals(task._primary_result);   // 发送处理结果
            sleep(2);                       // 休息2s
		}

	}

	ifs.close();
	// 子进程退出
	QThread::quit();
}

// 切分字符串
void MyThread::slicedString(std::vector<std::string>* v, const std::string& str)
{
	int begin = 0;
	while (true)
	{
		int pos = str.find(',', begin);
		if (std::string::npos == pos)
		{
			v->push_back(str.substr(begin));
			break;
		}
		v->push_back(str.substr(begin, pos - begin));
		begin = pos + 1;
	}
}
// 清洗数据
void MyThread::parse(Task* task, const std::string& line)
{
	std::vector<std::string> v;
	slicedString(&v, line); // 将数据放到我们的数组中

	for (int i = 0; i < 24; i++)
	{
		int j = 4 * i + 2;
		Data data;
		// 这里将 系数和面积都放进去
		data.set(v[1], std::stod(v[j]), std::stod(v[j + 1]), std::stod(v[j + 2]), std::stod(v[j + 3]), _area[i / 4], _coefficient_of_backrest_tube[i]);
		task->push_back(data);
	}
}
```

由于要保证程序的持续性运行,此时随机生成一些数据,

```cpp
void MyThread::run()
{
	bool headerData = true;
	std::string path = "./test.csv"; // 数据读取的位置
	std::ifstream ifs;
	ifs.open(path.c_str(), std::ifstream::in);
	std::string line;  // 将每一行的数据存到line中
	std::getline(ifs, line); // 清除掉第一行

	while (!_quit_flag)
	{
		// 确定我们的参数已经可以拿去了
		if (_area.empty() || _coefficient_of_backrest_tube.empty())
		{
			std::cout << "area and coefficient_of_backrest_tube is empty" << std::endl;
			sleep(1);
			continue;
		}
		// 下面是模拟我们数据处理的结果,然后发送过去的
		int j = 0;
		int begin = time(NULL);

		while (!_quit_flag)
		{
			/*std::getline(ifs, line);*/
			Task task;

			/*	parse(&task, line);*/
			// 这是一个测试
			for (int i = 0; i < 24; i++)
			{
				std::string time = "1714029266";                             // 时间戳
				double differentialPressure = qrand() % 100;                           // 一次风动压测点
				double primaryAirTemperatureMeasuringPoint = qrand() % 100;            // 一次风温测点
				double pulverizedCoalTemperatureMeasuringPoint = qrand() % 100;        // 煤粉温度测点
				double mixedTemperatureMeasuringPoint = qrand() % 100;                 // 混合温度测点
				double area = 1.4;                                           // 面积
				double coefficient = 1.9;                                    // 测速管风洞标定系数
				Data data;  //Data 是一个检测点的所有的数据,我们需要使用24个检测点
				data.set(time, differentialPressure, primaryAirTemperatureMeasuringPoint, pulverizedCoalTemperatureMeasuringPoint, mixedTemperatureMeasuringPoint, area, coefficient);
				task.push_back(data);
			}

			task.run();                     // 这里一个task就是我们24个监测点所有的数据,run函数是数据处理
			cleanseData(task._primary_result);                  // 清洗报警数据
			emit produceAllDataSignals(task._primary_result);   // 发送处理结果
			std::cout << "send " << ++j << std::endl;
			if (j % 1000 == 0)
			{
				int end = time(NULL);
				std::cout << "=======================" << std::endl;
				std::cout << end - begin << std::endl;
				begin = time(NULL);
				std::cout << "=======================" << std::endl;
			}
			sleep(2);                       // 休息2s
		}
	}

	ifs.close();
	// 子进程退出
	QThread::quit();
}
```

我们程序的监测点是24个,上述的一个**Data**对象就是一个监测点所有的的数据.

```cpp
// 仅仅计算一次的
struct Data
{
	Data();
	~Data();

	Data(const Data&);

	void set(const std::string&, double, double, double, double, double, double);

	std::string _time;                               // 时间戳
	double _differentialPressure;                    // 一次风动压测点
	double _primaryAirTemperatureMeasuringPoint;     // 一次风温测点
	double _pulverizedCoalTemperatureMeasuringPoint; // 煤粉温度测点
	double _mixedTemperatureMeasuringPoint;          // 混合温度测点
	double _area;                                    // 面积
	double _coefficient;                             // 测速管风洞标定系数
};
```

将24个检测点的数据作为一组数据进行处理,这是因为我们主线程中图形一次性显示的数据就是24个,因此我们把这些数据封装起来.

```cpp
class Task
{
private:
	std::string timestampToString(const std::string&);
public:
	Task();
	~Task();
	void run();
	void push_back(const Data&);
	void show();
	std::vector<struct Data> _primary_value;   // 输入的数据
	std::vector<struct Result> _primary_result;// 输出的数据
};
```

这里的run函数就是处理数据的函数,需要借助上面我们写的**MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem**类,看一下代码.

```cpp
void Task::run()
{
	for (int i = 0; i < _primary_value.size(); i++)
	{
		struct Result result;

		MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem::WindSpeed(
			&result._wind_speed
			, _primary_value[i]._primaryAirTemperatureMeasuringPoint
			, _primary_value[i]._differentialPressure
			, _primary_value[i]._coefficient);
		// 计算煤粉浓度
		MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem::pulverizedCoalConcentration(
			&result._pulverized_coal_concentration
			, _primary_value[i]._primaryAirTemperatureMeasuringPoint
			, _primary_value[i]._pulverizedCoalTemperatureMeasuringPoint
			, _primary_value[i]._mixedTemperatureMeasuringPoint);

		// 煤粉质量流量
		MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem::pulverizedCoalMassFlowRate(
			&result._pulverized_coal_mass_flow_rate
			, result._wind_speed
			, _primary_value[i]._area
			, _primary_value[i]._primaryAirTemperatureMeasuringPoint
			, result._pulverized_coal_concentration);
		// 计算风量
		MathematicalModelOfPrimaryAirPowderOnlineMonitoringSystem::airVolume(
			&result._air_volume
			, result._wind_speed
			, _primary_value[i]._area);
		// 时间转化
		result._time = timestampToString(_primary_value[i]._time);
		result._temperature = _primary_value[i]._primaryAirTemperatureMeasuringPoint;
		_primary_result.push_back(result);
	}
}
```

可以看到,我们将结果放在了一个叫做**Result**的类中了,他的成员如下

```cpp
struct Result
{
	Result();
	~Result();
	Result(const Result&);
	std::string _time;                      // 时间
	double _wind_speed;					    // 风速
	double _pulverized_coal_concentration;  // 煤粉浓度
	double _pulverized_coal_mass_flow_rate; // 煤粉质量流量
	double _air_volume;					    // 风量
	double _temperature;                    // 温度
};
```

数据计算的结果通过信号与槽机制发送给了主线程.这一点可以在上面看到,下面是简单的.

```cpp

void MyThread::run()
{
    //...
	while (!_quit_flag)
	{
   		//...

		while (!_quit_flag)
		{
			/*std::getline(ifs, line);*/
			Task task;

			/*	parse(&task, line);*/
			// 这是一个测试
			for (int i = 0; i < 24; i++)
			{
                //...
				task.push_back(data);
			}

			task.run();                     // 这里一个task就是我们24个监测点所有的数据,run函数是数据处理
			emit produceAllDataSignals(task._primary_result);   // 发送处理结果
			sleep(2);                       // 休息2s
		}
	}

	ifs.close();
	// 子进程退出
	QThread::quit();
}
```

> 目前已经将子线程的基本流程写好了,由于程序存在两个功能,记录报警数据和通道数据,为了方便,在子线程就将这些数据分离开来.

![image-20240613104731948](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613104731948.png)



![image-20240613104742023](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613104742023.png)

这里写的就是一个想法,具体的函数还没有完成.

```cpp
void MyThread::run()
{

	while (!_quit_flag)
	{
		while (!_quit_flag)
		{
			cleanseData(task._primary_result);                  // 清洗报警数据
			sleep(2);                       // 休息2s
		}
	}

	ifs.close();
	// 子进程退出
	QThread::quit();
}

/*
* 如何清洗我们的,
*/
void MyThread::cleanseData(const std::vector<struct Result>& allData)
{
	// 数据 A1-A4 ...F1-F4 共24组数据
	// 报警数据
	std::vector<struct AlertData> alert;

	/*for (int i = 0; i < allData.size(); i++)
	{
		if(i <)
	}*/
	emit produceAlarmDataSignals(alert);      // 传递报警数据

	// 通道数据
	std::vector<struct ChannelData> channel;
	produceChannelDataSignals(channel);
}

```

# 主线程

主线程的主要就是显示我们的数据处理的结果.主要分为四个主要功能.

![image-20240613105230583](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613105230583.png)

下面是主线程主要的的代码,将所有的功能集成到了**BoilerFeedPowderOnLineMonitoringSystemClass**类中

```cpp
/*
* 这是系统的主界面,所有的功能都在这里
* 可以通过点击菜单栏的选项进行相应的选择
*/

QT_BEGIN_NAMESPACE
namespace Ui { class BoilerFeedPowderOnLineMonitoringSystemClass; };
QT_END_NAMESPACE

class BoilerFeedPowderOnLineMonitoringSystem : public QMainWindow
{
	Q_OBJECT

public:
	BoilerFeedPowderOnLineMonitoringSystem(QWidget* parent = nullptr);
	~BoilerFeedPowderOnLineMonitoringSystem();

	void init(); // 进行所有功能的初始化
protected:
	void closeEvent(QCloseEvent*) override; //
private:
	void initThread();
	void initSystemSetting();
	void initWelcomeScreen(); // 初始化欢迎界面
	void initGiveAnAlarm();
	void initMyTime();
	void initSpout();
	void initBackrestCanal();
	void initWordOfCommand();
	void initQuit();

	void initStatusView();
	void initRodTypeWindPowderDiagram();
	void initTangentialCircleDiagramOfPrimaryWind();
	void initTrendChart();
	void initHistoricalTrendChart();

	void initDataProcessing();
	void initAlarmDatabase();
	void initChannelDatabase();

	void initAssist();

	void startThread();
private:
	Ui::BoilerFeedPowderOnLineMonitoringSystemClass* ui;
	ResultData _result_data;  // 解析的数据,由子线程发送到这里
	MyThread _my_thread;	  // 线程
	Configure* _configure;	  // 配置信息

	WelcomeScreen* _welcome_screen;		  // 欢迎界面
	GiveAnAlarm* _give_an_alarm;	      // 设定报警限
	MyTime* _my_time;	                  // 设定时间
	Spout* _spout;						  // 修改喷口面积
	BackrestCanal* _backrest_canal;		  // 修改靠背管系数
	WordOfCommand* _word_of_command;	  // 修改口令
	VerifyPassword* _verify_password;	  // 密码验证

	RodTypeWindPowderDiagram* _rod_type_wind_powder_diagram;	                      // 棒型风粉图
	TangentialCircleDiagramOfPrimaryWind* _tangential_circle_diagram_of_primary_wind; // 一次风切圆图
	TrendChart* _trend_chart;                                                         // 趋势图
	HistoricalTrendChart* _historical_trend_chart;                                    // 历史趋势图

	AlarmDatabase* _alarm_database;													  // 报警数据
	ChannelDatabase* _channel_database;												  // 通道数据
};
```

## 欢迎界面

由于程序运行先显示欢迎界面,因此这里先写出来,具体的主线程的流程暂时先不谈.

```cpp
class WelcomeScreen : public QWidget
{
	Q_OBJECT

public:
	WelcomeScreen(QWidget* parent = nullptr);
	~WelcomeScreen();
protected slots:
	void onButtonDoubleClicked();       // 点击按钮触发的槽函数
	void resetClickCount();             // 重置计数器
signals:
	void fromWelToMianScreenSignals();  // 双击之后,触发这个信号,转到主界面
	void welcomeScreenCloseSignals();   // 窗口关闭时,触发这个函数
protected:
	void closeEvent(QCloseEvent*);      // 重写窗口关闭的函数

private:
	Ui::WelcomeScreenClass* ui;
	QTimer* _doubleClickTimer;          // 时间控件
	int _clickCount;                    // 点击的计数器
};

WelcomeScreen::WelcomeScreen(QWidget* parent)
	: QWidget(parent)
	, ui(new Ui::WelcomeScreenClass())
	, _doubleClickTimer(new QTimer(this))
	, _clickCount(0)
{
	ui->setupUi(this);
	std::cout << "WelcomeScreen()" << std::endl;
	init();
}

void WelcomeScreen::init()
{
	// 窗口设置标题
	this->setWindowTitle("欢迎界面");
	// 检测鼠标的双击事件
	_doubleClickTimer->setInterval(QApplication::doubleClickInterval());
	connect(_doubleClickTimer, &QTimer::timeout, this, &WelcomeScreen::resetClickCount);
	connect(ui->welcome_pushButton, &QPushButton::clicked, this, &WelcomeScreen::onButtonDoubleClicked);
}
```



下面是代码的一些细节.其中为了实现鼠标双击事件,这里使用了一个定时器.

```cpp
_doubleClickTimer->setInterval(QApplication::doubleClickInterval());
```

1. `_doubleClickTimer` 是一个定时器对象,用于监测鼠标的双击事件.
2. `setInterval()` 方法用于设置定时器的间隔时间,单位为毫秒.
3. `QApplication::doubleClickInterval()` 是一个静态方法,它返回当前系统中定义的双击间隔时间.这个时间是用户在操作系统中设置的双击延迟时间,通常在 300-500 毫秒之间.
4. 将 `QApplication::doubleClickInterval()` 的返回值传给 `setInterval()` 方法,可以确保定时器的间隔时间与系统设置的双击延迟时间一致.这样可以确保程序能够正确地检测到用户的双击事件.

## 主线程流程

看一下main函数

```cpp
#include "BoilerFeedPowderOnLineMonitoringSystem.h"
#include <QtWidgets/QApplication>

int main(int argc, char* argv[])
{
	QApplication a(argc, argv);
	BoilerFeedPowderOnLineMonitoringSystem w; // 实例化所有功能的类
	w.hide();   // 主页面暂时先隐藏,需要先显示欢迎界面
	return a.exec();
}
```

可以发现,我们先构造处一个BoilerFeedPowderOnLineMonitoringSystem对象,然后进行事件循环等待.看一下他的构造函数.

```cpp
BoilerFeedPowderOnLineMonitoringSystem::BoilerFeedPowderOnLineMonitoringSystem(QWidget* parent)
	: QMainWindow(parent)
	, ui(new Ui::BoilerFeedPowderOnLineMonitoringSystemClass())
	, _configure(new Configure(nullptr))
	, _welcome_screen(nullptr)
	, _give_an_alarm(nullptr)
	, _my_time(nullptr)
	, _verify_password(nullptr)
	, _spout(nullptr)
	, _word_of_command(nullptr)
	, _rod_type_wind_powder_diagram(nullptr)
	, _tangential_circle_diagram_of_primary_wind(nullptr)
	, _trend_chart(nullptr)
	, _historical_trend_chart(nullptr)
	, _channel_database(nullptr)
	, _alarm_database(nullptr)
{
	ui->setupUi(this);
	std::cout << "BoilerFeedPowderOnLineMonitoringSystem()" << std::endl;
	init(); // 进行资源的构造
}

void BoilerFeedPowderOnLineMonitoringSystem::init()
{
	this->setWindowTitle("锅炉送粉在线监测系统");
	// 实例化我们的各个功能
	// 系统设置
	_give_an_alarm = new GiveAnAlarm(nullptr, _configure);
	_word_of_command = new WordOfCommand(nullptr, _configure);
	_my_time = new MyTime();
	_verify_password = new VerifyPassword(nullptr, _configure);
	_spout = new Spout(nullptr, _configure);
	_backrest_canal = new BackrestCanal(nullptr, _configure);

	// 四个图像,这里只需要县开辟两个
	//_rod_type_wind_powder_diagram = new RodTypeWindPowderDiagram(nullptr, &_result_data);
	//_tangential_circle_diagram_of_primary_wind = new TangentialCircleDiagramOfPrimaryWind;
	_trend_chart = new TrendChart(nullptr, &_result_data);
	_historical_trend_chart = new HistoricalTrendChart(nullptr, &_result_data);
	// 报警数据和通道数据
	_alarm_database = new AlarmDatabase(nullptr, &_result_data);
	_channel_database = new ChannelDatabase(nullptr, &_result_data);

	// 将系数发给我们工作的线程
	emit _my_thread.saveCoefficientSignals(_configure->getAllCoefficient());  // 防止系数已经更新了

	initWelcomeScreen();   // 欢迎窗口
	initSystemSetting();   // 系统设置
	initStatusView();      // 状态查看
	initDataProcessing();  // 数据处理
	initAssist();          // 帮助
	initThread();          // 设置下我们通过线程得到的数据
	startThread();         // 启动线程
}
```

### 处理参数



先看一下**Configure**类,这是我们的解析我们配置文件的类,配置文件为**configure.old - 副本.txt**.文件中的参数为类似KV结构的

![image-20240613110803263](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613110803263.png)

将配置文件进行读写,然后保存到一个哈希表中,然后通过信号与槽机制进行拿去和修改.

```cpp
class Configure : public QWidget
{
	Q_OBJECT
		friend class BoilerFeedPowderOnLineMonitoringSystem;
public:
	Configure(QWidget* parent = nullptr);
	~Configure();
	void init();                   // 初始化
	void alterAlarmLimitValue(const std::vector<std::string>&);   // 修改报警限值
	void alterSpout(const std::vector<std::string>&); // 修改喷口面积
	void alterBackrest(const std::vector<std::string>&); // 修改系数
	void alterPassword(const std::string&); //修改密码
	std::vector<std::string> getAllCoefficient();
private:
	void setPassword();           // 设置密码
	void setAlarmLimitValue();    // 给定确定的界限值
	void setAlarmLimitRange();    // 设置报警限的范围
	void saveConfigurationFile(); // 保存文件
	void setBackrest();           // 设置靠背管系数
	void setSpout();              // 设定喷口面积

signals:
	void setBackrestCanalSignals(const std::vector<std::string>&);
	void setSpoutSignals(const std::vector<std::string>&);
	void setPasswordSignals(const std::string&);
	void setAlarmLimitRangeSignals(const std::vector<std::string>&);
	void setAlarmLimitValueSignals(const std::vector<std::string>&);
private:
	std::string _configuration_file_path; // 配置文件路径
	std::unordered_map<std::string, std::string> _info_map; // 所有的参数保存在这个哈希表中,便于后期查找
};

```

### 子线程启动

```cpp
void BoilerFeedPowderOnLineMonitoringSystem::init()
{
    //...
	startThread();         // 启动线程
}

void BoilerFeedPowderOnLineMonitoringSystem::startThread()
{
	// 启动子线程
	_my_thread.start();
}
```

### 主线程关闭

对于QT而言,子窗口的关闭可能会造成整个程序的关闭,主要的机理我也是不太懂,为了解决这个问题,我们将重新子窗口的关闭函数,具体的代码我们在后面做一个演示,这里暂时不写,保证只有当主页面关闭或者欢迎界面时,我们才会关闭整个程序.关闭欢迎界面导致程序关闭这是因为欢迎界面只会在程序的初期出现.

```cpp
void BoilerFeedPowderOnLineMonitoringSystem::closeEvent(QCloseEvent* event)
{
	// 退出子线程
	_my_thread.quitThread();
	_my_thread.wait();

	// 让欢迎窗口退出
	if (_welcome_screen)
		_welcome_screen->close();
	// 退出窗口时,避免资源泄露,释放掉资源
	if (_give_an_alarm)
		delete _give_an_alarm;
	if (_my_time)
		delete _my_time;
	if (_verify_password)
		delete _verify_password;
	if (_spout)
		delete _spout;
	if (_backrest_canal)
		delete _backrest_canal;
	if (_word_of_command)
		delete _word_of_command;
	if (_rod_type_wind_powder_diagram)
		delete _rod_type_wind_powder_diagram;
	if (_tangential_circle_diagram_of_primary_wind)
		delete _tangential_circle_diagram_of_primary_wind;
	if (_trend_chart)
		delete _trend_chart;
	if (_historical_trend_chart)
		delete _historical_trend_chart;
	if (_channel_database)
		delete _channel_database;
	if (_alarm_database)
		delete _alarm_database;
	// 关闭窗口
	this->close();
}
```



## 系统设置

系统设置的功能来自**煤粉浓度说明书20231123.doc**文档.主要分为

- 设定拷贝管
- 设定喷口
- 设定报警限
- 修改口令
- 修订时间
- 退出

由于这里面的功能大多具有相似性,因此我们将每一类型作为说明,其他的在代码中存在一些注释.



### 修订报警限

该功能可以修改一次风燃烧器出口风速、一次风管煤粉浓度、一次风管温度等参数的上、下限报警值.

> 代码具体的想法是,当我们点击菜单栏的子菜单时,出发信号与槽机制.
>
> 然后通过_configure来触发信号与槽,进行报警限的设置.由于这是一个子窗口,因此,这里我们对窗口关闭函数做了一个重写,点击关闭时,窗口只需要隐藏就可以了.

```cpp
// 修订报警限
void BoilerFeedPowderOnLineMonitoringSystem::initGiveAnAlarm()
{
	connect(ui->action_give_an_alarm, &QAction::triggered, [=]() {
		if (nullptr == _give_an_alarm)
			_give_an_alarm = new GiveAnAlarm(nullptr, _configure);

		_configure->setAlarmLimitRange(); // 发送范围
		_configure->setAlarmLimitValue(); // 发送确定值

		this->hide();
		_give_an_alarm->show();
		//仅仅时为了查看报警限
		connect(_give_an_alarm, &GiveAnAlarm::fromGiveAnAlarmToMainScreenSignals, [=]() {
			_give_an_alarm->close();
			// 这里可以更新下参数,如果我们已经修改了呢
			});

		// 叉掉时只需要退出就可以了
		connect(_give_an_alarm, &GiveAnAlarm::giveAnAlarmCloseSignals, [=]() {
			_give_an_alarm->hide();  // 这里只需要隐藏就可以了
			this->show(); // 主窗口显示
			});
		});
}
```

下面是**GiveAnAlarm**类的具体成员.

```cpp
QT_BEGIN_NAMESPACE
namespace Ui { class GiveAnAlarmClass; };
QT_END_NAMESPACE

class GiveAnAlarm : public QWidget
{
	Q_OBJECT

public:
	GiveAnAlarm(QWidget* parent = nullptr, Configure* configure = nullptr);
	~GiveAnAlarm();
	void init();
signals:
	void giveAnAlarmCloseSignals();
	void fromGiveAnAlarmToMainScreenSignals();
private:
	void closeEvent(QCloseEvent*);
	int strfromDoubleToInt(const std::string&);  // 字符串转整数
	std::string intToStr(int);                   // 整数转字符串
private:
	Ui::GiveAnAlarmClass* ui;
	Configure* _configure;
};


//这是重写的关闭函数
void GiveAnAlarm::closeEvent(QCloseEvent*)
{
	emit giveAnAlarmCloseSignals();
}
```

### 靠背管系数修正

靠背管系数修正,是根据各个一次风管标定后,决定的靠背管系数.这个功能需要先进行一个密码的验证,我们先说一下密码的界面.具体的密码类为**VerifyPassword**,密码放在了配置文件中了.

```cpp
class VerifyPassword : public QWidget
{
	Q_OBJECT

public:
	VerifyPassword(QWidget* parent = nullptr, Configure* configure = nullptr);
	~VerifyPassword();
	void init();
	void setOption(int);
signals:
	void fromVerifyPasswordToSpoutSignalsIsTrue(); // 对面积是正确的
	void fromVerifyPasswordToBackrestCanalSignalsIsTrue(); // 对系数是正确的
	void fromVerifyPasswordSignalsIsFalse();
	void verifyPasswordCloseSignals();
private:
	void closeEvent(QCloseEvent*);
private:
	Ui::VerifyPasswordClass* ui;
	std::string _password;
	Configure* _configure;
	int _option;
};
```

接着说一下靠背管系数修正的流程.

```cpp
// 修改靠背管的系数
void BoilerFeedPowderOnLineMonitoringSystem::initBackrestCanal()
{
	connect(ui->action_backrest_canal, &QAction::triggered, [=]() {
		if (nullptr == _verify_password)
			_verify_password = new VerifyPassword(nullptr, _configure);

		// 设置密码
		_configure->setPassword();
		_verify_password->setOption(2);
		// 密码验证窗口显示
		_verify_password->show();

		connect(_verify_password, &VerifyPassword::verifyPasswordCloseSignals, [=]() {
			_verify_password->hide();
			this->show();
			});

		connect(_verify_password, &VerifyPassword::fromVerifyPasswordToBackrestCanalSignalsIsTrue, [=]() {
			// 密码验证成功
			_verify_password->hide();
			this->hide();

			if (nullptr == _backrest_canal)
				_backrest_canal = new BackrestCanal(nullptr, _configure);
			_configure->setBackrest();
			_backrest_canal->show();
			connect(_backrest_canal, &BackrestCanal::fromBackrestCanalToMainScreenSignals, [=]()
				{
					_backrest_canal->close();
				});

			connect(_backrest_canal, &BackrestCanal::backrestCanalCloseSignals, [=]() {
				_backrest_canal->hide();
				_verify_password->close();
				});
			});

		connect(_verify_password, &VerifyPassword::fromVerifyPasswordSignalsIsFalse, [=]() {
			_verify_password->close();
			});
		});
}
```

他的具体代码在下面

```cpp
QT_BEGIN_NAMESPACE
namespace Ui { class BackrestCanalClass; };
QT_END_NAMESPACE

class BackrestCanal : public QWidget
{
	Q_OBJECT

public:
	BackrestCanal(QWidget* parent = nullptr, Configure* configure = nullptr);
	~BackrestCanal();
	void init();
private:
	void setReadOnly(bool); // lable 控件是否可以被修改
signals:
	void fromBackrestCanalToMainScreenSignals();
	void backrestCanalCloseSignals();
private:
	void closeEvent(QCloseEvent*);
private:
	Ui::BackrestCanalClass* ui;
	Configure* _configure;
};
```

### 其他功能

由于大多功能的代码逻辑具有相似性,这里只粘贴处了代码

#### 修改口令

```cpp
// 修改口令
void BoilerFeedPowderOnLineMonitoringSystem::initWordOfCommand()
{
	connect(ui->action_word_of_command, &QAction::triggered, [=]() {
		if (nullptr == _word_of_command)
			_word_of_command = new WordOfCommand(nullptr, _configure);
		_configure->setPassword();


		this->hide();
		_word_of_command->show();

		connect(_word_of_command, &WordOfCommand::fromWordOfCommandToMainScreenSignals, [=]() {
			_word_of_command->close();
			});
		connect(_word_of_command, &WordOfCommand::wordOfCommandCloseSignals, [=]() {
			this->show();
			_word_of_command->hide();
			});
		});

}
QT_BEGIN_NAMESPACE
namespace Ui { class WordOfCommandClass; };
QT_END_NAMESPACE

class WordOfCommand : public QWidget
{
	Q_OBJECT

public:
	WordOfCommand(QWidget* parent = nullptr, Configure* configure = nullptr);
	~WordOfCommand();
	void init();
signals:
	void fromWordOfCommandToMainScreenSignals();
	void wordOfCommandCloseSignals();
private:
	void closeEvent(QCloseEvent*);
private:
	Ui::WordOfCommandClass* ui;
	Configure* _configure;
	std::string _password;
};
```



#### 修订时间

```cpp
// 修订时间
void BoilerFeedPowderOnLineMonitoringSystem::initMyTime()
{
	connect(ui->action_mytime, &QAction::triggered, [=]() {
		if (nullptr == _my_time)
			_my_time = new MyTime();

		this->hide();
		_my_time->show();

		// 返回主窗口
		connect(_my_time, &MyTime::fromMyTimeToMianScreenSignals, [=]()
			{
				_my_time->close();
			});

		connect(_my_time, &MyTime::myTimeCloseSignals, [=]() {
			_my_time->hide();
			this->show(); // 主窗口显示
			});
		});

}
```



#### 退出

```cpp
// 退出程序
void BoilerFeedPowderOnLineMonitoringSystem::initQuit()
{
	connect(ui->action_quit, &QAction::triggered, [=]()
		{
			this->close();
		});
}
```

## 状态查看

这个功能主要是四个图形显示,程序主要的问题就在这里,这个版本的程序是这个四个图形化界面同时存在,并且数据同时派发个这些界面,导致了随着数据派发的越来越多,最终导致程序由于图形更新事件处理的不及时造成卡顿和崩溃啊,这里我做了一个修改,这个4个界面,我们仍旧执行数据的派发,只让占据电脑显示界面的图形进行图形的更新,但是这只会延缓程序的崩溃啊,看看后面能不能把这个问题解决.

### 派发数据

由于子线程的数据我无法给到图形直接进行更新,这里多做了一步,将数据直接发送到主线程,统一进行派发.这个数据为**ResultData**类.

```cpp
#include "Task.h"
#include <QWidget>
#include "ChannelData.h"
#include "AlertData.h"

/*
* 由于子线程计算的数据无法直接给折线图,此时这里多上一步
* 将子线程结算的结果放在这里,然后进行派发
*/

// 棒型风粉图数据
struct BarPatternOfWindPowder
{
	double _wind_speed;     // 风速
	double	_concentration; // 浓度
	double _temperature;    // 温度
};
// 折线图数据
struct TendencyChartData
{
	int    _category;       // 类别
	double _wind_speed;     // 风速
	double _concentration;  // 浓度
	double _temperature_1;  // 温度1
	double _temperature_2;  // 温度2
};

class ResultData : public QWidget
{
	Q_OBJECT

public:
	ResultData(QWidget* parent = nullptr);
	~ResultData();
signals:
	// 棒型风粉图数据
	void barPatternOfWindPowderSignals(const std::vector<struct BarPatternOfWindPowder>&);
	// 趋势图
	void tendencyChartDataSignals(const std::vector<struct TendencyChartData>&);
	void alarmDataSignals(const struct AlertData&);
	void channeDataSignals(const struct ChannelData&);
public slots:
	// 将解析后的数据拿出来,进行派发
	void distributeAllData(std::vector<struct Result>);
	void distributeAlarmData(std::vector<struct AlertData>);
	void distributeChannelData(std::vector<struct ChannelData>);
};

```

下面是数据具体派发的流程.

```cpp

#include "ResultData.h"
ResultData::ResultData(QWidget* parent)
	: QWidget(parent)
{}

ResultData::~ResultData()
{}
// 派发图形的数据
void ResultData::distributeAllData(std::vector<struct Result> task)
{
	std::vector<struct BarPatternOfWindPowder> bar; // 棒型风粉图 数据
	std::vector<struct TendencyChartData> tendency; // 趋势图数据
	for (int i = 0; i < task.size(); i++)
	{
		// 单个保存数据
		//struct BarPatternOfWindPowder barData;
		//barData._wind_speed = task[i]._wind_speed;
		//barData._concentration = task[i]._pulverized_coal_concentration;
		//barData._temperature = task[i]._temperature;
		//bar.push_back(barData);

		//struct TendencyChartData tendencyData;                  // 这里有一个温度我不太确定,暂时充当一下
		//tendencyData._category = i;                            // 类别就是我们是24个数据的哪一个
		//tendencyData._wind_speed = task[i]._wind_speed + qrand() % 50;
		//tendencyData._concentration = task[i]._pulverized_coal_concentration + qrand() % 50;
		//tendencyData._temperature_1 = task[i]._temperature + qrand()*qrand()%100;
		//tendencyData._temperature_2 = task[i]._temperature + qrand() % 50;
		//tendency.push_back(tendencyData);

		//这是一个尝试
		struct BarPatternOfWindPowder barData;
		barData._wind_speed = qrand() % 100;
		barData._concentration = qrand() % 100;
		barData._temperature = qrand() % 100;
		bar.push_back(barData);

		struct TendencyChartData tendencyData;                  // 这里有一个温度我不太确定,暂时充当一下
		tendencyData._category = i;                             // 类别就是我们是24个数据的哪一个
		tendencyData._wind_speed = qrand() % 100;
		tendencyData._concentration = qrand() % 100;
		tendencyData._temperature_1 = qrand() % 100;
		tendencyData._temperature_2 = qrand() % 100;
		tendency.push_back(tendencyData);
	}
	emit barPatternOfWindPowderSignals(bar); // 发送 棒型风粉图 数据
	emit tendencyChartDataSignals(tendency); // 发送趋势图数据,包含历史趋势图
}

// 报警数据
void  ResultData::distributeAlarmData(std::vector<struct AlertData> data)
{
	/*for (int i = 0; i < data.size(); i++)
	{
		alarmDataSignals(data[i]);
	}*/

	struct AlertData v;
	static int i = 1;

	v._sensor_name = "测试" + std::to_string(i);
	v._alarm_type = "测试";
	v._initial_time_point = "测试";
	v._data = "测试";
	v._end_time_point = "测试";
	++i;
	alarmDataSignals(v);
}
//通道数据
void ResultData::distributeChannelData(std::vector<struct ChannelData> data)
{
	/*for (int i = 0; i < data.size(); i++)
	{
		channeDataSignals(data[i]);
	}*/
	struct ChannelData v;
	static int i = 1;
	v._name = "测试" + std::to_string(i);
	v._serial_number = "测试";
	v._slate_number = "测试";
	v._channel_number = "测试";
	v._type = "测试";
	v._range = "测试";
	v._measured_value = "测试";
	v._engineering_value = "测试";
	++i;
	channeDataSignals(v);
}
```

### 棒型风粉图

棒型风粉图是该装置的核心监视画面,如图12所示,显示器上半部显示24个喷燃器出口风速（m/s）,同时用棒状图和数字两种形式显示.

```cpp
// 棒型风粉图显示
void BoilerFeedPowderOnLineMonitoringSystem::initRodTypeWindPowderDiagram()
{
	connect(ui->action_rod_type_wind_powder_diagram, &QAction::triggered, [=]() {
		if (nullptr == _rod_type_wind_powder_diagram) // 实例化资源
			_rod_type_wind_powder_diagram = new RodTypeWindPowderDiagram(nullptr, &_result_data);

		// 更新参数, 避免前面修改了报警限
		emit _my_thread.saveCoefficientSignals(_configure->getAllCoefficient());  // 防止系数已经更新了
        // 信号和槽, 窗口退出后,怎么做
		connect(_rod_type_wind_powder_diagram, &RodTypeWindPowderDiagram::rodTypeWindPowderDiagramCloseSignals, [=]() {
			this->show(); // 主窗口显示
			_rod_type_wind_powder_diagram->hide();
			});

		
		this->hide();// 关闭主窗口
		_rod_type_wind_powder_diagram->show(); // 显示该窗口

		});
}
```

这个代码还是比较简单的.

```cpp
QT_BEGIN_NAMESPACE
namespace Ui { class RodTypeWindPowderDiagramClass; };
QT_END_NAMESPACE

class RodTypeWindPowderDiagram : public QWidget
{
	Q_OBJECT

public:
	RodTypeWindPowderDiagram(QWidget* parent = nullptr, ResultData* result_data = nullptr);
	~RodTypeWindPowderDiagram();
	void init();
private:
	void createChart();
	void updateData();
	void closeEvent(QCloseEvent*) override;

signals:
	void rodTypeWindPowderDiagramCloseSignals();

private:
	Ui::RodTypeWindPowderDiagramClass* ui;
	ResultData* _result_data;  // 派发数据
	// 三个图形
	BarChartWidget* _wind_speed_view;
	BarChartWidget* _pulverized_coal_concentration_view;
	BarChartWidget* _temperature_view;
};
```

为了方便管理,我么将24位数据作为一组,形成了一个柱状体.类型名为**BarChartWidget**,主要函数为写数据

```cpp
class BarChartWidget : public QWidget
{
	Q_OBJECT

public:
	BarChartWidget(QWidget* parent);
	~BarChartWidget();
	void setRange(int, int);
	void writeData(const std::vector<double>&);
	void createChart(int, int, int, int, const std::string&);
	void addXAxis();
private:
	QBarSet* _set;
	QBarSeries* _series;
	QChart* _chart;            // 文档类
	QChartView* _chartView;    // 视图
	QBarCategoryAxis* _axisX;  // X轴
	QValueAxis* _axisY;        // Y轴
};
// 写数据
// 写数据
void BarChartWidget::writeData(const std::vector<double>& data)
{
	if (_set->count() != 0)
	{
		for (int i = 0; i < data.size(); ++i)
		{
			_set->replace(i, data[i]);
		}
	}
	else
	{
		for (int i = 0; i < data.size(); ++i)
		{
			_set->append(data[i]);
		}
	}
	addXAxis(); // 更新X数据
	_chart->update(); // 更新图形
}
```

将棒型风粉图代码简单的分析下就可以,当数据发送过来的时候,进行一定的处理,然后就进行写进柱状图就可以了.

```cpp
RodTypeWindPowderDiagram::RodTypeWindPowderDiagram(QWidget* parent, ResultData* result_data)
	: QWidget(parent)
	, ui(new Ui::RodTypeWindPowderDiagramClass())
	, _result_data(result_data)
	, _wind_speed_view(nullptr)
	, _pulverized_coal_concentration_view(nullptr)
	, _temperature_view(nullptr)
{
	ui->setupUi(this);
	std::cout << "RodTypeWindPowderDiagram()" << std::endl;
	init();
}
void RodTypeWindPowderDiagram::init()
{
	this->setWindowTitle("棒型风粉图");
	createChart();
	updateData();
}
void RodTypeWindPowderDiagram::updateData()
{
	connect(_result_data, &ResultData::barPatternOfWindPowderSignals, [=](const std::vector<struct BarPatternOfWindPowder>& data) {
		std::vector<double> v1; // 保存24个风速
		std::vector<double> v2; // 保存24个浓度
		std::vector<double> v3; // 保存24个温度

		for (int i = 0; i < data.size(); i++)
		{
			v1.push_back(data[i]._wind_speed);
			v2.push_back(data[i]._concentration);
			v3.push_back(data[i]._temperature);
		}
		if (this->isVisible())
		{
			_wind_speed_view->writeData(v1);
			_pulverized_coal_concentration_view->writeData(v2);
			_temperature_view->writeData(v3);
		}
		else
		{
			std::cout << "no1" << std::endl;
		}

		});
}
```

### 一次风切圆图

一次风切圆图,直观地显示了五层一次风管中煤粉浓度（红色条形图）和喷燃器出口流速（白色条形图）,它形象地显示了每层喷燃器出口流速是否均衡、火焰是否在炉膛中心,以便指导司炉操作.这个版本只写了6个矩形26组风速和浓度的动态变化,暂时没有考虑中间圆形的移动,后面的可以填上.

```cpp

// 一次风切圆图
void BoilerFeedPowderOnLineMonitoringSystem::initTangentialCircleDiagramOfPrimaryWind()
{
	connect(ui->action_tangential_circle_diagram_of_primary_wind, &QAction::triggered, [=]() {
		if (nullptr == _tangential_circle_diagram_of_primary_wind) // 实例化资源
			_tangential_circle_diagram_of_primary_wind = new TangentialCircleDiagramOfPrimaryWind;
		// 更新参数
		emit _my_thread.saveCoefficientSignals(_configure->getAllCoefficient());  // 防止系数已经更新了

		connect(_tangential_circle_diagram_of_primary_wind, &TangentialCircleDiagramOfPrimaryWind::tangentialCircleDiagramOfPrimaryWindCloseSignals, [=]() {
			this->show(); // 主窗口显示
			_tangential_circle_diagram_of_primary_wind->hide();
			});

		this->hide();// 关闭主窗口
		_tangential_circle_diagram_of_primary_wind->show();// 显示该窗口
		});
}
```

具体的代码如下.

```cpp
QT_BEGIN_NAMESPACE
namespace Ui { class TangentialCircleDiagramOfPrimaryWindClass; };
QT_END_NAMESPACE

class TangentialCircleDiagramOfPrimaryWind : public QWidget
{
	Q_OBJECT

public:
	TangentialCircleDiagramOfPrimaryWind(QWidget* parent = nullptr);
	~TangentialCircleDiagramOfPrimaryWind();
	void init();
signals:
	void tangentialCircleDiagramOfPrimaryWindCloseSignals();
private:
	void closeEvent(QCloseEvent*);
private:
	Ui::TangentialCircleDiagramOfPrimaryWindClass* ui;
	QTimer* _time;
};
```

这里的重点是一个矩形和内部直线的绘制,我们将矩形作为了一个类,名字为**PrimaryWindCutCircleDiagramView**,简单说一下.我们使用了QT的绘图功能,为了方便,对于矩形的一个角延申出来的线,我们使用两条直线分别代表风速和浓度.它们而这共同组成了一条直线,这两条直线的总长度被限制在起点为矩形的角,终点为矩形便的1/3位置处,预留一部分空间给圆形.

```cpp
#include <QWidget>
#include <iostream>
#include <qpainter.h>

#define RECTANGULAR_LINE_WIDTH 5  // 矩形线段宽度
#define WIDTH_OF_A_CIRCLE 5       // 圆的线段宽度
#define DIAMETER 50               // 圆的直径
#define STRAIGHT_LINE_WIDTH 5     // 斜线的宽度
class PrimaryWindCutCircleDiagramView : public QWidget
{
	Q_OBJECT

public:
	PrimaryWindCutCircleDiagramView(QWidget* parent);
	~PrimaryWindCutCircleDiagramView();
	void writeData(double, double, double, double, double, double, double, double);

protected:
	void paintEvent(QPaintEvent*) override;
private:
	std::pair<int, int> _outlet_velocity_one_begin;  // 浓度1的起点
	std::pair<int, int> _outlet_velocity_one_end;    // 浓度1的终点
	std::pair<int, int>	_wind_speed_one_begin;       // 流速的起点
	std::pair<int, int>	_wind_speed_one_end;         // 流速的终点

	std::pair<int, int> _outlet_velocity_two_begin;  // 浓度2的起点
	std::pair<int, int> _outlet_velocity_two_end;    // 浓度2的终点
	std::pair<int, int>	_wind_speed_two_begin;       // 流速的起点
	std::pair<int, int>	_wind_speed_two_end;         // 流速的终点

	std::pair<int, int> _outlet_velocity_three_begin;  // 浓度3的起点
	std::pair<int, int> _outlet_velocity_three_end;    // 浓度3的终点
	std::pair<int, int>	_wind_speed_three_begin;       // 流速的起点
	std::pair<int, int>	_wind_speed_three_end;         // 流速的终点

	std::pair<int, int> _outlet_velocity_four_begin;  // 浓度4的起点
	std::pair<int, int> _outlet_velocity_four_end;    // 浓度4的终点
	std::pair<int, int>	_wind_speed_four_begin;       // 流速的起点
	std::pair<int, int>	_wind_speed_four_end;         // 流速的终点
};
```

当数据来临时,我们计算它们二者的相对值,这样可以控制这二者的在规定范围内两天直线的移动的情况.

```cpp
// 写数据,需要计算我们两个参数的相对值,然后根据比例进行更新我们的两个不同颜色的图形
// 注意,这里少了一个功能,中间的圆形移动少了
void PrimaryWindCutCircleDiagramView::writeData(double velocityOne, double speedOne
	, double velocityTwo, double speedTwo
	, double velocityThree, double speedThree
	, double velocityFour, double speedFour)
{
	int width = this->width();
	int height = this->height();

	double ratioOne = velocityOne / (velocityOne + speedOne);
	double ratioTwo = velocityTwo / (velocityTwo + speedTwo);
	double ratioThree = velocityThree / (velocityThree + speedThree);
	double ratioFour = velocityFour / (velocityFour + speedFour);

	_outlet_velocity_one_begin = { width - RECTANGULAR_LINE_WIDTH,height - RECTANGULAR_LINE_WIDTH };
	_outlet_velocity_one_end.first = (int)(2.0 * width / 3 + (1.0 - ratioOne) * width / 3.0);
	_outlet_velocity_one_end.second = (int)(2.0 * height / 3 + (1.0 - ratioOne) * height / 3.0);
	_wind_speed_one_begin = _outlet_velocity_one_end;
	_wind_speed_one_end = { 2 * width / 3, 2 * height / 3 };

	_outlet_velocity_two_begin = { RECTANGULAR_LINE_WIDTH, height - RECTANGULAR_LINE_WIDTH };
	_outlet_velocity_two_end.first = (int)(ratioTwo * 1.0 * width / 3.0);
	_outlet_velocity_two_end.second = (int)(2.0 * height / 3 + (1 - ratioTwo) * 1.0 * height / 3);
	_wind_speed_two_begin = _outlet_velocity_two_end;
	_wind_speed_two_end = { width / 3, 2 * height / 3 };

	_outlet_velocity_three_begin = { RECTANGULAR_LINE_WIDTH,RECTANGULAR_LINE_WIDTH };
	_outlet_velocity_three_end.first = (int)(ratioThree * 1.0 * width / 3);
	_outlet_velocity_three_end.second = (int)(ratioThree * 1.0 * height / 3);
	_wind_speed_three_begin = _outlet_velocity_three_end;
	_wind_speed_three_end = { width / 3,height / 3 };

	_outlet_velocity_four_begin = { width - RECTANGULAR_LINE_WIDTH ,RECTANGULAR_LINE_WIDTH };
	_outlet_velocity_four_end.first = (int)(2.0 * width / 3 + (1.0 - ratioFour) * width / 3.0);
	_outlet_velocity_four_end.second = (int)(ratioFour * 1.0 * height / 3);
	_wind_speed_four_begin = _outlet_velocity_four_end;
	_wind_speed_four_end = { 2 * width / 3, height / 3 };
	update();
}
```

### 趋势图

实时趋势图可以显示风速、浓度和温度在30分钟内的变化趋势,每次可以用四种颜色分别显示4条曲线.趋势图的左边是四条曲线所显示的量值单位,趋势图的上面四个选择框可以很方便地选择不同的变量.由于只说了时间,没说说多少个数据点,因此我们假设一定的秒数来一个数据,进而转化为数据的个数.

> 这个版本存在性能损失,当数据点慢了的时候,我们每次新增一个数据,对应的数组需要头删,时间复杂度为O(N),并且该显现的折线图需要将数据全部清洗掉,重新添加,及其耗费时间.

```cpp
// 趋势图
void BoilerFeedPowderOnLineMonitoringSystem::initTrendChart()
{
	connect(ui->action_trend_chart, &QAction::triggered, [=]() {
		if (nullptr == _trend_chart)
			_trend_chart = new TrendChart(nullptr, &_result_data);
		// 更新参数
		emit _my_thread.saveCoefficientSignals(_configure->getAllCoefficient());  // 防止系数已经更新了

		connect(_trend_chart, &TrendChart::trendChartCloseSignals, [=]() {
			this->show(); // 主窗口显示
			_trend_chart->hide();
			});
		this->hide();// 关闭主窗口
		_trend_chart->show();// 显示该窗口
		});
}
```

这个趋势图要保存24个监测点在30min内所有的数据,这里我么和使用了一个哈希表作为数据保存的结构.具体的结构如下.

![image-20240613123056261](D:/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/image-20240613123056261.png)

由于我们具有可以选择24个监测点那个折线图,为了方便管理,我么这里使用4个折线,分别代表风速,煤粉浓度,以及两个温度.当我们选择时,将原本折线的数据全部情空,将被选择的数据放进去,然后更新图形.这存在性能的损失.

```cpp
void TrendChart::initMap()
{
	for (int i = 1; i <= 24; i++) // 创建哈希表
	{
		std::string str = std::to_string(i);
		_wind_speed_map[str];
		_concentration_map[str];
		_temperature_1[str];
		_temperature_2[str];
		// 先开辟空间
		_wind_speed_map[str].reserve(NUMBER_OF_DATA);
		_concentration_map[str].reserve(NUMBER_OF_DATA);
		_temperature_1[str].reserve(NUMBER_OF_DATA);
		_temperature_2[str].reserve(NUMBER_OF_DATA);
	}
}

void TrendChart::updateData()
{
	// 选中之后更新数据
	connect(ui->wind_speed, &QComboBox::currentTextChanged, [=](const QString& s) {
		_updateData(WINDCHOICE, s.toStdString(), true);
		});
	connect(ui->temperature_1, &QComboBox::currentTextChanged, [=](const QString& s) {
		_updateData(TEMPERATUREONECHOICE, s.toStdString(), true);
		});
	connect(ui->temperature_2, &QComboBox::currentTextChanged, [=](const QString& s) {
		_updateData(TEMPERATURETWOCHOICE, s.toStdString(), true);
		});
	connect(ui->concentration, &QComboBox::currentTextChanged, [=](const QString& s) {
		_updateData(CONCENTRATIONCHOICE, s.toStdString(), true);
		});

	connect(_result_data, &ResultData::tendencyChartDataSignals, [=](const std::vector<struct TendencyChartData>& data) {
		// 查看我们目前的元素
		std::string windStr = ui->wind_speed->currentText().toStdString();
		std::string concentrationStr = ui->concentration->currentText().toStdString();
		std::string temperatureOneStr = ui->temperature_1->currentText().toStdString();
		std::string temperatureTwoStr = ui->temperature_2->currentText().toStdString();
		// 查一下我们数据的个数
		int num = _wind_speed_map[windStr].size();

		bool falg = false;
		if (num > NUMBER_OF_DATA)
		{
			falg = true;
			// 对于之前的所有的元素最旧的元素要删除掉
			for (int i = 0; i < 24; i++)
			{
				std::string str = std::to_string(i + 1);
				_wind_speed_map[str].erase(_wind_speed_map[str].begin()); // 删除风速的
				_concentration_map[str].erase(_concentration_map[str].begin());  // 删除密度的
				_temperature_1[str].erase(_temperature_1[str].begin());          // 删除温度1的
				_temperature_2[str].erase(_temperature_2[str].begin());// 删除温度2的
			}
		}

		// 然后把最新的数据放进来
		for (int i = 0; i < data.size(); ++i)
		{
			std::string str = std::to_string(i + 1);
			_wind_speed_map[str].push_back(data[i]._wind_speed);
			_concentration_map[str].push_back(data[i]._concentration);
			_temperature_1[str].push_back(data[i]._temperature_1);
			_temperature_2[str].push_back(data[i]._temperature_2);
		}

		if (this->isVisible())
		{
			_updateData(WINDCHOICE, windStr, falg);                    // 更新风速, 其中更新风速的windStr号数据
			_updateData(CONCENTRATIONCHOICE, concentrationStr, falg);
			_updateData(TEMPERATUREONECHOICE, temperatureOneStr, falg);
			_updateData(TEMPERATURETWOCHOICE, temperatureTwoStr, falg);

			std::cout << "update data" << std::endl;
		}
		else
		{
			std::cout << "no3: " << num << std::endl;
		}
		
		});
}
```

### 历史趋势图

历史趋势图可以显示风速、浓度和2个温度在前120分钟内的变化趋势,它和趋势图一样,可以通过历史趋势图上的四个选择框选择不同的变量,在每次选择完后必需单击查看数据,才能显示每条选择的曲线.他的实现和趋势图图差不多,因此这里不多说了.这里存在一个功能,可以选取前面时间和后面时间的数据,这里需要注意下.

```cpp
// 历史图
void BoilerFeedPowderOnLineMonitoringSystem::initHistoricalTrendChart()
{
	connect(ui->action_historical_trend_chart, &QAction::triggered, [=]() {
		if (nullptr == _historical_trend_chart) // 实例化资源
			_historical_trend_chart = new HistoricalTrendChart(nullptr, &_result_data);
		emit _my_thread.saveCoefficientSignals(_configure->getAllCoefficient());  // 防止系数已经更新了

		connect(_historical_trend_chart, &HistoricalTrendChart::historicalTrendChartSignals, [=]() {
			this->show(); // 主窗口显示
			_historical_trend_chart->hide();
			});

		this->hide();
		_historical_trend_chart->show();
		});
}
```

下面是他的代码.

```cpp
QT_BEGIN_NAMESPACE
namespace Ui { class HistoricalTrendChartClass; };
QT_END_NAMESPACE

class HistoricalTrendChart : public QMainWindow
{
	Q_OBJECT

public:
	HistoricalTrendChart(QWidget* parent = nullptr, ResultData* resultData = nullptr);
	~HistoricalTrendChart();
	void init();
signals:
	void historicalTrendChartSignals();
private:
	void initMap();
	void updateData();
	void _updateData(int, const std::string&, int, int);
	void createChart();
	void closeEvent(QCloseEvent*);
private:
	Ui::HistoricalTrendChartClass* ui;
	ResultData* _resultData; // 收到的数据

	std::unordered_map<std::string, std::vector<double>> _wind_speed_map;         // 保存24个风速
	std::unordered_map<std::string, std::vector<double>> _concentration_map;      // 保存24个煤粉浓度
	std::unordered_map<std::string, std::vector<double>> _temperature_1_map;      // 保存24个温度1
	std::unordered_map<std::string, std::vector<double>> _temperature_2_map;      // 保存24个温度2

	QChartView* _chartView;           // QChartView 用于展示 QChart
	QChart* _chart;                   // QChart 则容纳和管理一个或多个数据系列
	QValueAxis* _x;                   // X轴
	QValueAxis* _y_wind;              // 风速Y轴
	QValueAxis* _y_concentration;     // 浓度Y轴
	QValueAxis* _y_temperature_1;     // 温度1 Y轴
	QValueAxis* _y_temperature_2;     // 温度2 Y轴
	QLineSeries* _line_wind;          // 风速折线
	QLineSeries* _line_concentration; // 浓度折线
	QLineSeries* _line_temperature_1; // 温度1折线
	QLineSeries* _line_temperature_2; // 温度2折线

	int _left_wind;      // 风速左侧的范围
	int _right_wind;     // 风速右侧的范围

	int _left_concentration;      // 浓度左侧的范围
	int _right_concentration;     // 浓度右侧的范围

	int _left_temperature_1;      // 温度1左侧的范围
	int _right_temperature_1;     // 温度2右侧的范围

	int _left_temperature_2;      // 温度2左侧的范围
	int _right_temperature_2;     // 温度2右侧的范围
	bool _left_right_clickde;     // 点击了左侧或者右侧
};
```

这里重点说下我们该如何显示前面一部分时间的数据,我们这里所有的数据都保存起来了,如果我们要显示前面和后面的数据,那么这里就是将折线图的数据进行一部分更新,至于更新多少个数据点,根据我们点击一次按钮走几步来进行计算,但是这里存在界限

- 一直点击向左侧按钮,最小才会更新到第一个数据点
- 一直点击最右侧按钮,最大才会到达我们最新的数据点

这个版本的写法有些粗糙,后面看看能否更新一下.

```cpp
// 初始化哈希表
void HistoricalTrendChart::initMap()
{
	for (int i = 1; i <= 24; i++) // 创建哈希表
	{
		std::string str = std::to_string(i);
		_wind_speed_map[str];
		_concentration_map[str];
		_temperature_1_map[str];
		_temperature_2_map[str];

		// 先开辟空间
		_wind_speed_map[str].reserve(NUMBER_OF_DATA_HIS);
		_concentration_map[str].reserve(NUMBER_OF_DATA_HIS);
		_temperature_1_map[str].reserve(NUMBER_OF_DATA_HIS);
		_temperature_2_map[str].reserve(NUMBER_OF_DATA_HIS);

		int a = 10;
	}
}

void HistoricalTrendChart::updateData()
{
    // 点击左侧
	connect(ui->pushButton_left, &QPushButton::clicked, [=]() {
		_left_right_clickde = true;
		std::string windStr = ui->wind_speed->currentText().toStdString();
		std::string concentrationStr = ui->concentration->currentText().toStdString();
		std::string temperatureOneStr = ui->temperature_1->currentText().toStdString();
		std::string temperatureTwoStr = ui->temperature_2->currentText().toStdString();
		if (_line_wind->count())
		{
			_right_wind = std::max(0, (int)(_line_wind->at(_line_wind->count() - 1).x() - STEP_SIZE - 1));
			_left_wind = std::max(0, _right_wind - STAGE_FREQUENCY);
			if (!_wind_speed_map[windStr].empty() && _right_wind == 0)
			{
				// 为了避免我们_left_wind和_right_wind都是0的情况,刷新不出图形
				// 但是这里有一个问题,我们把_right_wind值为, 如果我们数组没有数据,
				// 那么这个图新还是不会显示,这里的概率很小, 毕竟的人的操作速度还是慢于计算机的, 暂时先忽略
				_right_wind = 1;
			}
			_updateData(WINDCHOICE_HIS, windStr, _left_wind, _right_wind);
		}
		if (_line_concentration->count())
		{
			_right_concentration = std::max(0, (int)(_line_concentration->at(_line_concentration->count() - 1).x() - STEP_SIZE - 1));
			_left_concentration = std::max(0, _right_concentration - STAGE_FREQUENCY);

			if (!_concentration_map[concentrationStr].empty() && _right_concentration == 0)
			{
				_right_concentration = 1;
			}
			_updateData(CONCENTRATIONCHOICE_HIS, concentrationStr, _left_concentration, _right_concentration);
		}
		if (_line_temperature_1->count())
		{
			_right_temperature_1 = std::max(0, (int)(_line_temperature_1->at(_line_temperature_1->count() - 1).x() - STEP_SIZE - 1));
			_left_temperature_1 = std::max(0, _right_temperature_1 - STAGE_FREQUENCY);
			if (!_temperature_1_map[temperatureOneStr].empty() && _right_temperature_1 == 0)
			{
				_right_temperature_1 = 1;
			}
			_updateData(TEMPERATUREONECHOICE_HIS, temperatureOneStr, _left_temperature_1, _right_temperature_1);
		}
		if (_line_temperature_2->count())
		{
			_right_temperature_2 = std::max(0, (int)(_line_temperature_2->at(_line_temperature_2->count() - 1).x() - STEP_SIZE - 1));
			_left_temperature_2 = std::max(0, _right_temperature_2 - STAGE_FREQUENCY);
			if (!_temperature_2_map[temperatureTwoStr].empty() && _right_temperature_2 == 0)
			{
				_right_temperature_2 = 1;
			}
			_updateData(TEMPERATURETWOCHOICE_HIS, temperatureTwoStr, _left_temperature_2, _right_temperature_2);
		}
		});
    // 点击右侧
	connect(ui->pushButton_right, &QPushButton::clicked, [=]() {
		_left_right_clickde = true;

		std::string windStr = ui->wind_speed->currentText().toStdString();
		std::string concentrationStr = ui->concentration->currentText().toStdString();
		std::string temperatureOneStr = ui->temperature_1->currentText().toStdString();
		std::string temperatureTwoStr = ui->temperature_2->currentText().toStdString();

		if (_line_wind->count())
		{
			_right_wind = std::min((int)(_wind_speed_map[windStr].size()), std::min(NUMBER_OF_DATA_HIS + 1, (int)(_line_wind->at(_line_wind->count() - 1).x() + STEP_SIZE + 1)));

			_left_wind = std::max(0, _right_wind - STAGE_FREQUENCY);
			if (!_wind_speed_map[windStr].empty() && _right_wind == 0)
			{
				// 为了避免我们_left_wind和_right_wind都是0的情况,刷新不出图形
				// 但是这里有一个问题,我们把_right_wind值为, 如果我们数组没有数据,
				// 那么这个图新还是不会显示,这里的概率很小, 毕竟的人的操作速度还是慢于计算机的, 暂时先忽略
				_right_wind = 1;
			}
			_updateData(WINDCHOICE_HIS, windStr, _left_wind, _right_wind);
		}

		if (_line_concentration->count())
		{
			_right_concentration = std::min((int)(_concentration_map[concentrationStr].size()), std::min(NUMBER_OF_DATA_HIS + 1, (int)(_line_concentration->at(_line_concentration->count() - 1).x() + STEP_SIZE + 1)));

			_left_concentration = std::max(0, _right_concentration - STAGE_FREQUENCY);

			if (!_concentration_map[concentrationStr].empty() && _right_concentration == 0)
			{
				_right_concentration = 1;
			}
			_updateData(CONCENTRATIONCHOICE_HIS, concentrationStr, _left_concentration, _right_concentration);
		}
		if (_line_temperature_1->count())
		{
			_right_temperature_1 = std::min((int)(_temperature_1_map[temperatureOneStr].size()), std::min(NUMBER_OF_DATA_HIS + 1, (int)(_line_temperature_1->at(_line_temperature_1->count() - 1).x() + STEP_SIZE + 1)));

			_left_temperature_1 = std::max(0, _right_temperature_1 - STAGE_FREQUENCY);
			if (!_temperature_1_map[temperatureOneStr].empty() && _right_temperature_1 == 0)
			{
				_right_temperature_1 = 1;
			}
			_updateData(TEMPERATUREONECHOICE_HIS, temperatureOneStr, _left_temperature_1, _right_temperature_1);
		}
		if (_line_temperature_2->count())
		{
			_right_temperature_2 = std::min((int)(_temperature_2_map[temperatureTwoStr].size()), std::min(NUMBER_OF_DATA_HIS + 1, (int)(_line_temperature_2->at(_line_temperature_2->count() - 1).x() + STEP_SIZE + 1)));

			_left_temperature_2 = std::max(0, _right_temperature_2 - STAGE_FREQUENCY);
			if (!_temperature_2_map[temperatureTwoStr].empty() && _right_temperature_2 == 0)
			{
				_right_temperature_2 = 1;
			}
			_updateData(TEMPERATURETWOCHOICE_HIS, temperatureTwoStr, _left_temperature_2, _right_temperature_2);
		}
		});
	
		});
}
```



## 数据处理

主要分为报警数据处理、通道数据处理功能.

### 报警数据

报警数据记录了1000条已发生报警的一次风速、煤粉浓度和一次风管内的温度报警.具体的流程为

```cpp
// 报警数据
void BoilerFeedPowderOnLineMonitoringSystem::initAlarmDatabase()
{
	connect(ui->action_alarm_database, &QAction::triggered, [=]() {
		
		if (_alarm_database == nullptr)  // 实例化资源
			_alarm_database = new AlarmDatabase;
	

		// 信号与槽函数
		connect(_alarm_database, &AlarmDatabase::fromAlarmDatabaseToMainScreenSignals, [=]()
			{
				_alarm_database->close();
			});
		connect(_alarm_database, &AlarmDatabase::alarmDatabaseCloseSignals, [=]() {
			this->show(); // 主窗口显示
			_alarm_database->hide();
			});

		this->hide();  // 隐藏主窗口
		_alarm_database->show();// 显示报警数据窗口

		});
}
```

AlarmDatabase类集合了我们的报警数据,下面是他的代码的具体的成员

```cpp
// 报警数据集合成的类
struct AlertData
{
public:
	AlertData();
	~AlertData();

	AlertData(const AlertData&);
	std::string _sensor_name; // 传感器名字
	std::string _alarm_type;  // 出限类型
	std::string _initial_time_point; // 起始时间点
	std::string	_data; // 数据
	std::string _end_time_point;// 结束时间点
};


QT_BEGIN_NAMESPACE
namespace Ui { class AlarmDatabaseClass; };
QT_END_NAMESPACE

class AlarmDatabase : public QWidget
{
	Q_OBJECT

public:
	AlarmDatabase(QWidget* parent = nullptr, ResultData* result_data = nullptr);
	~AlarmDatabase();
	void init();
signals:
	void alarmDatabaseCloseSignals();
	void fromAlarmDatabaseToMainScreenSignals();
private:
	void closeEvent(QCloseEvent*);
	void setTableWidget(); // 设置表格
	void writeData(const struct AlertData&);
	void showView(int);
private:
	Ui::AlarmDatabaseClass* ui;
	ResultData* _result_data;  // 派发数据
	int _current_page_count;
	int _number_of_total_pages;
	std::vector<struct AlertData> _v;
};

```

这里主要的函数是写数据,这个版本的写数据存在很大的性能损失,可以优化一下.

```cpp

// 写数据, 如果数据超过我们的数据的范围,保存数据的数组先头删,在接着插入
// 然后遍历每一个数组,将数组的元素添加到表格中
// 这个性能上有很大的损失,这个版本主要是为了测试,后面可以修改下
void AlarmDatabase::writeData(const struct AlertData& data)
{
	if (_v.size() == ROW * NUMBER_OF_TOTAL_PAGES)
	{
		_v.erase(_v.begin());
		_v.push_back(data);
		std::string _sensor_name; // 传感器名字

		for (int i = 0; i < _v.size(); ++i)
		{
			ui->tableWidget->setItem(i, 0, new QTableWidgetItem(_v[i]._sensor_name.c_str()));
			ui->tableWidget->setItem(i, 1, new QTableWidgetItem(_v[i]._alarm_type.c_str()));
			ui->tableWidget->setItem(i, 2, new QTableWidgetItem(_v[i]._initial_time_point.c_str()));
			ui->tableWidget->setItem(i, 3, new QTableWidgetItem(_v[i]._data.c_str()));
			ui->tableWidget->setItem(i, 4, new QTableWidgetItem(_v[i]._end_time_point.c_str()));
		}
	}
	else
	{
		_v.push_back(data);
		ui->tableWidget->setItem(_v.size() - 1, 0, new QTableWidgetItem(_v.back()._sensor_name.c_str()));
		ui->tableWidget->setItem(_v.size() - 1, 1, new QTableWidgetItem(_v.back()._alarm_type.c_str()));
		ui->tableWidget->setItem(_v.size() - 1, 2, new QTableWidgetItem(_v.back()._initial_time_point.c_str()));
		ui->tableWidget->setItem(_v.size() - 1, 3, new QTableWidgetItem(_v.back()._data.c_str()));
		ui->tableWidget->setItem(_v.size() - 1, 4, new QTableWidgetItem(_v.back()._end_time_point.c_str()));
	}

	
	if (this->isVisible()) // 如果该界面显示了,则更新我们的表格
	{
		ui->tableWidget->update();
	}

	// 设置当前页和总页数
	_number_of_total_pages = _v.size() / ROW;
	if (_v.size() % ROW != 0)
		_number_of_total_pages = _number_of_total_pages + 1;

	ui->label_cur->setText(std::to_string(_current_page_count).c_str());
	ui->label_total->setText(std::to_string(_number_of_total_pages).c_str());

	if (this->isVisible())
	{
		showView(_current_page_count);
	}
	else
	{
		std::cout << "no5" << std::endl;
	}
}
```

### 通道数据

通道数据主要用于检查数据采集站送来的信号是否正确,它对判断故障并分析原因是非常有用的.由于我们还为使用信号,同时这个部分在文档中没有说明,那么对子线程哪里清洗这通道数据就不知道是否是正确的了,后面可以修改下.通道数据存在的问题个报警数据是一样的.

```cpp

// 通道数据
void BoilerFeedPowderOnLineMonitoringSystem::initChannelDatabase()
{
	connect(ui->action_channel_database, &QAction::triggered, [=]() {
		if (nullptr == _channel_database) // 实例化资源
			_channel_database = new ChannelDatabase;

	    // 信号和槽函数
		connect(_channel_database, &ChannelDatabase::fromChannelDatabaseToMainScreenSignals, [=]()
			{
				_channel_database->close();
			});
		connect(_channel_database, &ChannelDatabase::channelDatabaseCloseSignals, [=]() {
			this->show(); // 主窗口显示
			_channel_database->hide();
			});

		this->hide();// 隐藏主窗口
		_channel_database->show();// 显示报警数据窗口
		});
}


// 通道数据集合成的类
#include <string>

struct ChannelData
{
	ChannelData();
	~ChannelData();

	ChannelData(const ChannelData&);
	std::string _name;
	std::string _serial_number;
	std::string	 _slate_number;
	std::string	_channel_number;
	std::string	_type;
	std::string	_range;
	std::string	_measured_value;
	std::string	_engineering_value;
};


QT_BEGIN_NAMESPACE
namespace Ui { class ChannelDatabaseClass; };
QT_END_NAMESPACE

class ChannelDatabase : public QWidget
{
	Q_OBJECT

public:
	ChannelDatabase(QWidget* parent = nullptr, ResultData* result_data = nullptr);
	~ChannelDatabase();
	void init();
signals:
	void channelDatabaseCloseSignals();
	void fromChannelDatabaseToMainScreenSignals();
private:
	void closeEvent(QCloseEvent*);
	void setTableWidget(); // 设置表格
	void writeData(const struct ChannelData&);
	void showView(int);
private:
	ResultData* _result_data;  // 派发数据
	Ui::ChannelDatabaseClass* ui;
	int _current_page_count;
	int _number_of_total_pages;
	std::vector<struct ChannelData> _v;
};
```

## 帮助

这个功能文档中暂时没有,看一下后面是否存在.
